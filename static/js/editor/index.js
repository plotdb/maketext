// Generated by LiveScript 1.3.0
var slice$ = [].slice;
history.scrollRestoration = 'manual';
$(document).ready(function(){
  var k, ref$, v, ret, editor, updateText, scrollto, list, res$, html, i$, to$, i, code, j$, j, d, initSlider, initColorpicker, clusterize, maketext, queries;
  for (k in ref$ = effects) {
    v = ref$[k];
    ret = null;
    eval(v.js);
    if (ret) {
      v.js = ret;
    }
  }
  window.editor = editor = {
    effects: effects,
    toggle: function(v){
      var svg;
      if (v == null) {
        v = !document.body.classList.contains('editing');
      }
      document.body.classList[!v ? 'remove' : 'add']('editing');
      if (!v) {
        svg = document.querySelector('#cooltext svg');
        return svg.parentNode.removeChild(svg);
      }
    },
    config: {
      cur: {
        fontSize: 64
      },
      old: {}
    }
  };
  updateText = function(node){
    var textInput, value;
    node = node || document.querySelector('#text-input');
    textInput = document.querySelector('#text-input');
    value = node.value || 'Hello World!';
    Array.from(document.querySelectorAll('.gallery text')).map(function(d, i){
      return d.textContent = value;
    });
    Array.from(document.querySelectorAll('#cooltext text')).map(function(it){
      return it.textContent = value;
    });
    return textInput.value = value;
  };
  window.scrollto = scrollto = function(node){
    return $('html,body').animate({
      scrollTop: $(node).offset().top
    }, 300);
  };
  document.querySelector('#landing input').addEventListener('keyup', function(e){
    if (e.keyCode === 13) {
      scrollto('#top');
    }
    return updateText(this);
  });
  document.querySelector('#text-input').addEventListener('keyup', function(){
    return updateText(this);
  });
  editor.update = function(name, value){
    var svg, this$ = this;
    this.config.old = JSON.parse(JSON.stringify(this.config.cur));
    this.config.cur[name] = value;
    svg = document.querySelector('#cooltext svg');
    if (document.body.classList.contains('editing')) {
      this.effects[effects.type].js.watch(this.config.cur, this.config.old, svg);
      if (name === 'background') {
        svg.style.background = value;
      }
      if (name === 'fontSize') {
        Array.from(svg.querySelectorAll('text')).map(function(it){
          return it.style.fontSize = value + "px";
        });
      }
      return;
    }
    if (name === 'fontSize') {
      Array.from(document.querySelectorAll('.gallery text')).map(function(node, i){
        return node.style.fontSize = value + "px";
      });
    }
    Array.from(document.querySelectorAll('.gallery .item')).map(function(d, i){
      var type;
      if (!d.parentNode.style.opacity) {
        return;
      }
      type = d.getAttribute('data-type');
      if (!(this$.effects[type].js && this$.effects[type].watch)) {
        return;
      }
      return this$.effects[type].js.watch(this$.config.cur, this$.config.old, d);
    });
    if (name === 'background') {
      return Array.from(document.querySelectorAll('.gallery svg')).map(function(d, i){
        return d.style.background = value;
      });
    }
  };
  res$ = [];
  for (k in ref$ = effects) {
    v = ref$[k];
    res$.push([k, v]);
  }
  list = res$;
  html = [];
  for (i$ = 0, to$ = list.length; i$ < to$; i$ += 2) {
    i = i$;
    code = "";
    for (j$ = 0; j$ <= 1; ++j$) {
      j = j$;
      d = list[i + j];
      if (!d) {
        break;
      }
      d[1].html = d[1].html.replace("<svg", "<svg width='100%' height='100%'");
      d[1].html = d[1].html.replace("0 0 500 150", "0 0 500 150");
      code += "<div class=\"item\" data-type=\"" + d[0] + "\"><div class=\"inner\">" + d[1].html + "</div></div>";
    }
    html.push("<div class=\"line\" style=\"visibility:hidden\">" + code + "</div>");
  }
  initSlider = function(node, key, value){
    var n, x$;
    n = node.querySelector('.irs-input');
    n.setAttribute('data-name', key);
    x$ = $(n);
    x$.val(value['default']) || 0;
    x$.ionRangeSlider({
      min: value.min || 0,
      max: value.max || 100,
      step: value.step || 1,
      onChange: function(data){
        return editor.update(key, data.from);
      }
    });
    return x$;
  };
  initColorpicker = function(node, key, value){
    var ldcp;
    ldcp = new ldColorPicker(node.querySelector('input'), {});
    return ldcp.on('change', function(it){
      editor.update(key, it);
      return node.querySelector('.inner').style.background = it;
    });
  };
  document.querySelector('.gallery').addEventListener('click', function(e){
    var target, type, html, svg, bkcolor, effect, options, colors, k, v, ref$, node, ref1$, results$ = [];
    target = e.target;
    if (!(target && target.classList && target.classList.contains('item'))) {
      return;
    }
    type = target.getAttribute('data-type');
    if (!type) {
      return;
    }
    html = effects[type].html;
    html = html.replace(/id="([^"]+)"/g, 'id="editing-$1"');
    html = html.replace(/url\(#([^)]+)\)/g, 'url(#editing-$1)');
    document.querySelector('#cooltext').innerHTML = html;
    svg = document.querySelector('#cooltext svg');
    bkcolor = getComputedStyle(svg).backgroundColor || '#fff';
    Array.from(svg.querySelectorAll('feImage')).map(function(d, i){
      var href, ref$, w, h;
      href = d.getAttributeNS('http://www.w3.org/1999/xlink', 'href') || d.getAttribute('href');
      if (/^data:image/.exec(href)) {
        return;
      }
      ref$ = [d.getAttribute('width'), d.getAttribute('height')].map(function(it){
        return (/(\d+)/.exec(it) || [0, 1024])[1];
      }), w = ref$[0], h = ref$[1];
      return smiltool.urlToDataurl(href, w, h).then(function(it){
        return d.setAttributeNS('http://www.w3.org/1999/xlink', 'href', it);
      });
    });
    editor.toggle(true);
    Array.from(document.querySelectorAll('#cooltext text')).map(function(it){
      return it.textContent = document.querySelector('#text-input').value || 'Hello World';
    });
    editor.effects.type = type;
    effect = editor.effects[type];
    options = document.querySelector('#editor-custom-options');
    options.innerHTML = '';
    if (effect.js && effect.js.edit) {
      colors = (function(){
        var ref$, results$ = [];
        for (k in ref$ = effect.js.edit) {
          v = ref$[k];
          results$.push(v);
        }
        return results$;
      }()).filter(function(it){
        return it.type === 'color';
      }).map(function(it){
        return it['default'];
      });
      for (k in ref$ = effect.js.edit) {
        v = ref$[k];
        node = document.querySelector("#editor-option-sample-" + v.type);
        if (!node) {
          continue;
        }
        node = node.cloneNode(true);
        if (v.type === 'color') {
          node.querySelector('label').textContent = v.name;
          node.querySelector('input').setAttribute('name', k);
          initColorpicker(node, k, v);
        } else if (v.type === 'number') {
          node.querySelector('label').textContent = v.name;
          node.querySelector('input').setAttribute('name', k, v);
          initSlider(node, k, v);
        }
        options.appendChild(node);
      }
      setPalette([bkcolor].concat(colors));
      for (k in ref$ = effect.js.edit) {
        v = ref$[k];
        editor.update(k, v['default']);
      }
    } else {
      options.innerHTML = "<div class='col-sm'><div class='empty'></div></div>";
      setPalette([bkcolor]);
    }
    for (k in ref$ = (ref1$ = editor.config).cur || (ref1$.cur = {})) {
      v = ref$[k];
      results$.push(editor.update(k, v));
    }
    return results$;
  });
  clusterize = new Clusterize({
    rows: html,
    scrollElem: document.querySelector('body'),
    contentElem: document.querySelector('#gallery'),
    rows_in_block: 50
  });
  document.addEventListener('scroll', function(e){
    var scrolltop, editor, height;
    scrolltop = document.scrollingElement.scrollTop;
    editor = document.querySelector('#editor');
    if (scrolltop > 200) {
      editor.classList.add('on');
    } else {
      editor.classList.remove('on');
    }
    height = window.innerHeight;
    return Array.from(document.querySelectorAll('.gallery .line')).map(function(d, i){
      var box;
      box = d.getBoundingClientRect();
      if (box.y + box.height < 0 || box.y > height) {
        d.style.visibility = 'hidden';
      } else {
        d.style.visibility = 'visible';
      }
      if (box.y + box.height < 0 || box.y + box.height / 3 > height) {
        d.style.opacity = 0;
        return d.style.transform = "scale(0.9)";
      } else {
        d.style.opacity = 1;
        return d.style.transform = "scale(1)";
      }
    });
  });
  window.subscribe = function(){
    var node, email, ret;
    node = document.querySelector('#subscribe');
    node.classList.remove('done', 'fail');
    node.classList.add('loading');
    email = document.querySelector('#email').value;
    ret = /^[^@]+@[^.]+\.(.+)$/.exec(email || '');
    if (!ret || !email) {
      return;
    }
    return $.ajax({
      url: '/d/newsletter-subscription',
      method: 'PUT',
      data: {
        email: email
      }
    }).then(function(){
      node.classList.remove('loading');
      return node.classList.add('done');
    }).fail(function(){
      node.classList.remove('loading');
      return node.classList.add('fail');
    });
  };
  /*
  # API Functionality
   * Export Input
     -  t: [text input]
           auto fill text input and scroll into gallery
     -  s: [font size]
           pre-set font size
  
   * Export events:
     - image.ready / fired when use click SVG/PNG button
       - type: ANY(image/png image/svg+xml)
       - name: [name]
  
   * Eventbus usage example:
     - maketext.editor.on \image.ready, -> console.log it
  
   DOM that is expected to be used by API user:
     editor-download-btn
       .btn[data-type=svg]
       .btn[data-type=png]
  
  */
  window.maketext = maketext = {
    editor: {
      input: function(it){
        var node;
        node = document.querySelector('#landing input');
        node.value = it;
        return updateText(node);
      },
      evtHandler: {},
      on: function(n, cb){
        var ref$;
        return ((ref$ = this.evtHandler)[n] || (ref$[n] = [])).push(cb);
      },
      fire: function(n){
        var v, i$, ref$, len$, cb;
        v = slice$.call(arguments, 1);
        for (i$ = 0, len$ = (ref$ = this.evtHandler[n] || []).length; i$ < len$; ++i$) {
          cb = ref$[i$];
          cb.apply(this, v);
        }
        return window.postMessage({
          n: n,
          data: v
        }, '*');
      }
    }
  };
  queries = (window.location.search || "?").substring(1).split('&').map(function(it){
    return it.split('=');
  }).filter(function(it){
    return it[0];
  });
  queries.filter(function(it){
    return it[0] === 't';
  }).slice(0, 1).map(function(it){
    maketext.editor.input(decodeURIComponent(it[1]));
    return scrollto('#top');
  });
  queries.filter(function(it){
    return it[0] === 's' && !isNaN(+it[1]);
  }).slice(0, 1).map(function(it){
    return $('#font-size-slider .up.irs-input').val(+it[1]);
  });
  ldColorPicker.init();
  return Array.from(document.querySelectorAll('#font-size-slider .up.irs-input')).map(function(d, i){
    var v, x$;
    editor.update('fontSize', v = +d.value || 64);
    x$ = $(d);
    x$.val(v);
    x$.ionRangeSlider({
      onChange: function(data){
        return editor.update('fontSize', data.from);
      }
    });
    return x$;
  });
});