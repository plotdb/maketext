// Generated by LiveScript 1.3.0
window.convert = {
  prepare: function(){
    return new Promise(function(res, rej){
      var svg, style, node, this$ = this;
      svg = document.querySelector('#cooltext svg').cloneNode(true);
      svg.setAttribute('width', '500px');
      svg.setAttribute('height', '150px');
      style = document.createElement("style");
      style.textContent = "text {\n  font-size: 60px;\n  font-family: Arial Black;\n  dominant-baseline: middle;\n  text-anchor: middle;\n}";
      svg.appendChild(style);
      node = document.querySelector('#svg-work-area');
      if (!node) {
        node = document.createElement("div");
        node.setAttribute('id', 'svg-work-area');
        document.body.appendChild(node);
      }
      node.appendChild(svg);
      return textToSvg.load("/assets/fonts/ttf/" + (window.fontname || 'ArialBlack') + "-Regular.ttf", function(e, tts){
        var text, textValue, d, path, i$, ref$, len$, name, that, pbox, box, x, y;
        text = svg.querySelector('text');
        textValue = text.textContent || 'Hello World';
        d = tts.getD(textValue);
        path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute('d', d);
        for (i$ = 0, len$ = (ref$ = ['fill', 'stroke', 'stroke-width', 'filter']).length; i$ < len$; ++i$) {
          name = ref$[i$];
          if (that = text.getAttribute(name)) {
            path.setAttribute(name, that);
          }
        }
        text.parentNode.insertBefore(path, text);
        text.parentNode.removeChild(text);
        ref$ = [
          path.getBBox(), {
            width: 500,
            height: 150
          }
        ], pbox = ref$[0], box = ref$[1];
        x = (box.width - pbox.width) * 0.5 - pbox.x;
        y = (box.height - pbox.height) * 0.5 - pbox.y;
        path.setAttribute("transform", "translate(" + x + ", " + y + ")");
        return res({
          svg: svg,
          text: textValue
        });
      });
    });
  },
  download: function(option){
    var that, blob, url, x$, y$;
    option == null && (option = {});
    $('#download').modal('show');
    if (that = option.blob) {
      blob = that;
    } else if (option.content) {
      blob = new Blob([option.content], {
        type: option.type
      });
    } else {
      null;
    }
    url = URL.createObjectURL(blob);
    x$ = document.querySelector('#download .result');
    x$.style.backgroundImage = "url(" + url + ")";
    y$ = document.querySelector('#download .btn');
    y$.setAttribute('href', url);
    y$.setAttribute('download', (option.name || 'output') + "." + (option.postfix || 'png'));
    return y$;
  },
  svg: function(){
    var this$ = this;
    return this.prepare().then(function(arg$){
      var svg, text;
      svg = arg$.svg, text = arg$.text;
      return this$.download({
        content: svg.outerHTML,
        type: 'image/svg+xml',
        name: text,
        postfix: 'svg'
      });
    });
  },
  png: function(){
    var textValue, this$ = this;
    textValue = '';
    return this.prepare().then(function(arg$){
      var svg, text;
      svg = arg$.svg, text = arg$.text;
      textValue = text;
      return smiltool.svgToDataurl(svg.outerHTML);
    }).then(function(it){
      return smiltool.urlToDataurl(it, 500, 150);
    }).then(function(it){
      return smiltool.dataurlToBlob(it);
    }).then(function(it){
      return this$.download({
        blob: it,
        name: textValue,
        postfix: 'png'
      });
    });
  }
};