// Generated by LiveScript 1.3.0
window.convert = {
  prepare: function(){
    return new Promise(function(res, rej){
      var svg, svgWidth, feImages, style, node, this$ = this;
      svg = document.querySelector('#cooltext svg').cloneNode(true);
      svgWidth = document.querySelector('#cooltext').getBoundingClientRect().width;
      svg.setAttribute('width', svgWidth + "px");
      svg.setAttribute('height', '170px');
      feImages = Array.from(svg.querySelectorAll('feImage')).map(function(d, i){
        var href, ret;
        href = d.getAttributeNS('http://www.w3.org/1999/xlink', 'href') || d.getAttribute('href');
        ret = /^(data:image\/svg\+xml[^,]*?),([^]+)$/gm.exec(href);
        if (ret && !/base64/.exec(ret[1])) {
          href = ret[1] + ";base64," + btoa(ret[2]);
          return d.setAttributeNS('http://www.w3.org/1999/xlink', 'href', href);
        }
      });
      style = document.createElement("style");
      style.textContent = "text {\n  font-size: 64px;\n  font-family: Arial Black;\n  dominant-baseline: central;\n  text-anchor: middle;\n}";
      svg.appendChild(style);
      node = document.querySelector('#svg-work-area');
      if (!node) {
        node = document.createElement("div");
        node.setAttribute('id', 'svg-work-area');
        document.body.appendChild(node);
      }
      node.appendChild(svg);
      return textToSvg.load("/assets/fonts/ttf/" + (window.fontname || 'ArialBlack') + "-Regular.ttf", function(e, tts){
        return Array.from(svg.querySelectorAll('text')).map(function(text, i){
          var fontSize, textValue, d, g1, g2, path, parent, i$, ref$, len$, name, that, pbox, box, x, y;
          text = svg.querySelector('text');
          fontSize = getComputedStyle(text).fontSize;
          fontSize = +(/(\d+)/.exec(fontSize) || [0, 64])[1];
          textValue = text.textContent || 'Hello World';
          d = tts.getD(textValue, {
            fontSize: fontSize
          });
          g1 = document.createElementNS("http://www.w3.org/2000/svg", "g");
          g2 = document.createElementNS("http://www.w3.org/2000/svg", "g");
          path = document.createElementNS("http://www.w3.org/2000/svg", "path");
          parent = text.parentNode;
          path.setAttribute('d', d);
          for (i$ = 0, len$ = (ref$ = ['fill', 'stroke', 'stroke-width']).length; i$ < len$; ++i$) {
            name = ref$[i$];
            if (that = text.getAttribute(name)) {
              path.setAttribute(name, that);
            }
          }
          parent.insertBefore(g1, text);
          g1.appendChild(g2);
          g2.appendChild(path);
          g1.setAttribute('filter', text.getAttribute('filter'));
          parent.removeChild(text);
          ref$ = [
            path.getBBox(), {
              width: 500,
              height: 150
            }
          ], pbox = ref$[0], box = ref$[1];
          x = (box.width - pbox.width) * 0.5 - pbox.x;
          y = (box.height - pbox.height) * 0.5 - pbox.y;
          g2.setAttribute("transform", "translate(" + x + ", " + y + ")");
          return res({
            svg: svg,
            text: textValue,
            width: svgWidth
          });
        });
      });
    });
  },
  download: function(option){
    var that, blob, url, x$, y$;
    option == null && (option = {});
    $('#download').modal('show');
    if (that = option.blob) {
      blob = that;
    } else if (option.content) {
      blob = new Blob([option.content], {
        type: option.type
      });
    } else {
      null;
    }
    url = URL.createObjectURL(blob);
    x$ = document.querySelector('#download .result');
    x$.style.backgroundImage = "url(" + url + ")";
    y$ = document.querySelector('#download .btn');
    y$.setAttribute('href', url);
    y$.setAttribute('download', (option.name || 'output') + "." + (option.postfix || 'png'));
    return y$;
  },
  svg: function(){
    var this$ = this;
    return this.prepare().then(function(arg$){
      var svg, text;
      svg = arg$.svg, text = arg$.text;
      return this$.download({
        content: svg.outerHTML,
        type: 'image/svg+xml',
        name: text,
        postfix: 'svg'
      });
    });
  },
  png: function(){
    var ref$, textValue, svgWidth, this$ = this;
    ref$ = ['', 1024], textValue = ref$[0], svgWidth = ref$[1];
    return this.prepare().then(function(arg$){
      var svg, text, width;
      svg = arg$.svg, text = arg$.text, width = arg$.width;
      textValue = text;
      svgWidth = width;
      return smiltool.svgToDataurl(svg.outerHTML);
    }).then(function(it){
      return smiltool.urlToDataurl(it, svgWidth, 170);
    }).then(function(it){
      return smiltool.dataurlToBlob(it);
    }).then(function(it){
      return this$.download({
        blob: it,
        name: textValue,
        postfix: 'png'
      });
    });
  }
};